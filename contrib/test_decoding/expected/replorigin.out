-- predictability
SET synchronous_commit = on;
CREATE TABLE origin_tbl(id serial primary key, data text);
CREATE TABLE target_tbl(id serial primary key, data text);
SELECT pg_replication_origin_create('test_decoding: regression_slot');
 pg_replication_origin_create 
------------------------------
                            1
(1 row)

-- ensure duplicate creations fail
SELECT pg_replication_origin_create('test_decoding: regression_slot');
ERROR:  duplicate key value violates unique constraint "pg_replication_origin_roname_index"
DETAIL:  Key (roname)=(test_decoding: regression_slot) already exists.
-- Create a second origin too
SELECT pg_replication_origin_create('test_decoding: regression_slot 2');
 pg_replication_origin_create 
------------------------------
                            2
(1 row)

--ensure deletions work (once)
SELECT pg_replication_origin_create('test_decoding: temp');
 pg_replication_origin_create 
------------------------------
                            3
(1 row)

SELECT pg_replication_origin_drop('test_decoding: temp');
 pg_replication_origin_drop 
----------------------------
 
(1 row)

SELECT pg_replication_origin_drop('test_decoding: temp');
ERROR:  cache lookup failed for replication origin 'test_decoding: temp'
SELECT 'init' FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');
 ?column? 
----------
 init
(1 row)

-- origin tx
INSERT INTO origin_tbl(data) VALUES ('will be replicated and decoded and decoded again');
INSERT INTO target_tbl(data)
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '1');
-- as is normal, the insert into target_tbl shows up
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '1');
                                                                                    data                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 BEGIN
 table public.target_tbl: INSERT: id[integer]:1 data[text]:'BEGIN'
 table public.target_tbl: INSERT: id[integer]:2 data[text]:'table public.origin_tbl: INSERT: id[integer]:1 data[text]:''will be replicated and decoded and decoded again'''
 table public.target_tbl: INSERT: id[integer]:3 data[text]:'COMMIT'
 COMMIT
(5 rows)

INSERT INTO origin_tbl(data) VALUES ('will be replicated, but not decoded again');
-- mark session as replaying
SELECT pg_replication_origin_session_setup('test_decoding: regression_slot');
 pg_replication_origin_session_setup 
-------------------------------------
 
(1 row)

-- ensure we prevent duplicate setup
SELECT pg_replication_origin_session_setup('test_decoding: regression_slot');
ERROR:  cannot setup replication origin when one is already setup
BEGIN;
-- setup transaction origin
SELECT pg_replication_origin_xact_setup('0/aabbccdd', '2013-01-01 00:00');
 pg_replication_origin_xact_setup 
----------------------------------
 
(1 row)

INSERT INTO target_tbl(data)
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '1', 'only-local', '1');
COMMIT;
-- check replication progress for the session is correct
SELECT pg_replication_origin_session_progress(false);
 pg_replication_origin_session_progress 
----------------------------------------
 0/AABBCCDD
(1 row)

SELECT pg_replication_origin_session_progress(true);
 pg_replication_origin_session_progress 
----------------------------------------
 0/AABBCCDD
(1 row)

SELECT pg_replication_origin_session_reset();
 pg_replication_origin_session_reset 
-------------------------------------
 
(1 row)

SELECT local_id, external_id, remote_lsn, local_lsn <> '0/0' FROM pg_replication_origin_status;
 local_id |          external_id           | remote_lsn | ?column? 
----------+--------------------------------+------------+----------
        1 | test_decoding: regression_slot | 0/AABBCCDD | t
(1 row)

-- check replication progress identified by name is correct
SELECT pg_replication_origin_progress('test_decoding: regression_slot', false);
 pg_replication_origin_progress 
--------------------------------
 0/AABBCCDD
(1 row)

SELECT pg_replication_origin_progress('test_decoding: regression_slot', true);
 pg_replication_origin_progress 
--------------------------------
 0/AABBCCDD
(1 row)

-- ensure reset requires previously setup state
SELECT pg_replication_origin_session_reset();
ERROR:  no replication origin is configured
-- and magically the replayed xact will be filtered!
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '1', 'only-local', '1');
 data 
------
(0 rows)

--but new original changes still show up
INSERT INTO origin_tbl(data) VALUES ('will be replicated');
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '1',  'only-local', '1');
                                      data                                      
--------------------------------------------------------------------------------
 BEGIN
 table public.origin_tbl: INSERT: id[integer]:3 data[text]:'will be replicated'
 COMMIT
(3 rows)

-- This time we'll prepare a series of transactions to decode in one go
-- rather than decoding one by one.
--
-- First, to make sure remote-originated tx's are not filtered out when only-local is unset,
-- we need another tx with an origin. This time we'll set a different origin for each
-- change.
SELECT pg_replication_origin_session_setup('test_decoding: regression_slot');
 pg_replication_origin_session_setup 
-------------------------------------
 
(1 row)

BEGIN;
SELECT pg_replication_origin_xact_setup('0/aabbccff', '2013-01-01 00:10');
 pg_replication_origin_xact_setup 
----------------------------------
 
(1 row)

INSERT INTO origin_tbl(data) VALUES ('will be replicated even though remotely originated');
SELECT pg_replication_origin_xact_setup('0/aabbcd00', '2013-01-01 00:11');
 pg_replication_origin_xact_setup 
----------------------------------
 
(1 row)

INSERT INTO origin_tbl(data) VALUES ('will also be replicated even though remotely originated');
-- Change the origin replication identifier mid-transaction
SELECT pg_replication_origin_session_reset();
 pg_replication_origin_session_reset 
-------------------------------------
 
(1 row)

SELECT pg_replication_origin_session_setup('test_decoding: regression_slot 2');
 pg_replication_origin_session_setup 
-------------------------------------
 
(1 row)

SELECT pg_replication_origin_xact_setup('0/aabbcd01', '2013-01-01 00:13');
 pg_replication_origin_xact_setup 
----------------------------------
 
(1 row)

INSERT INTO origin_tbl(data) VALUES ('from second origin');
COMMIT;
-- then run an empty tx, since this test will be setting skip-empty-xacts=0
-- Note that we need to do something, just something that won't get decoded,
-- to force a commit to be recorded.
BEGIN;
SELECT pg_replication_origin_xact_setup('1/aabbccff', '2013-01-01 00:20');
 pg_replication_origin_xact_setup 
----------------------------------
 
(1 row)

CREATE TEMPORARY TABLE test_empty_tx(blah integer);
COMMIT;
-- Decode with options not otherwise tested - skip empty xacts on, only-local off. Can't include xids since they'll change each run.
SELECT data FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL, 'include-xids', '0', 'skip-empty-xacts', '0',  'only-local', '0', 'include-origins', '1');
                                                                                    data                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 BEGIN -- origin:'test_decoding: regression_slot 2'@0/AABBCD01
 table public.origin_tbl: INSERT: id[integer]:4 data[text]:'will be replicated even though remotely originated' -- origin:'test_decoding: regression_slot'@0/AABBCD01
 table public.origin_tbl: INSERT: id[integer]:5 data[text]:'will also be replicated even though remotely originated' -- origin:'test_decoding: regression_slot'@0/AABBCD01
 table public.origin_tbl: INSERT: id[integer]:6 data[text]:'from second origin' -- origin:'test_decoding: regression_slot 2'@0/AABBCD01
 COMMIT -- origin:'test_decoding: regression_slot 2'@0/AABBCD01
 BEGIN -- origin:'test_decoding: regression_slot 2'@1/AABBCCFF
 COMMIT -- origin:'test_decoding: regression_slot 2'@1/AABBCCFF
(7 rows)

SELECT pg_replication_origin_session_reset();
 pg_replication_origin_session_reset 
-------------------------------------
 
(1 row)

SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot 
--------------------------
 
(1 row)

SELECT pg_replication_origin_drop('test_decoding: regression_slot');
 pg_replication_origin_drop 
----------------------------
 
(1 row)

